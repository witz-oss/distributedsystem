/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "RPCTasks_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kOperationValues[] = {
  Operation::ADD,
  Operation::SUBTRACT
};
const char* _kOperationNames[] = {
  "ADD",
  "SUBTRACT"
};
const std::map<int, const char*> _Operation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kOperationValues, _kOperationNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Operation::type& val) {
  std::map<int, const char*>::const_iterator it = _Operation_VALUES_TO_NAMES.find(val);
  if (it != _Operation_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Operation::type& val) {
  std::map<int, const char*>::const_iterator it = _Operation_VALUES_TO_NAMES.find(val);
  if (it != _Operation_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Matrix::~Matrix() noexcept {
}


void Matrix::__set_id(const int32_t val) {
  this->id = val;
}

void Matrix::__set_resultMatrix(const int32_t val) {
  this->resultMatrix = val;
}

void Matrix::__set_matrixA(const std::vector<std::vector<int32_t> > & val) {
  this->matrixA = val;
}

void Matrix::__set_matrixB(const std::vector<std::vector<int32_t> > & val) {
  this->matrixB = val;
}

void Matrix::__set_matrixResult(const std::vector<std::vector<int32_t> > & val) {
  this->matrixResult = val;
}
std::ostream& operator<<(std::ostream& out, const Matrix& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Matrix::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->resultMatrix);
          this->__isset.resultMatrix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrixA.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->matrixA.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              {
                this->matrixA[_i4].clear();
                uint32_t _size5;
                ::apache::thrift::protocol::TType _etype8;
                xfer += iprot->readListBegin(_etype8, _size5);
                this->matrixA[_i4].resize(_size5);
                uint32_t _i9;
                for (_i9 = 0; _i9 < _size5; ++_i9)
                {
                  xfer += iprot->readI32(this->matrixA[_i4][_i9]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.matrixA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrixB.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->matrixB.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              {
                this->matrixB[_i14].clear();
                uint32_t _size15;
                ::apache::thrift::protocol::TType _etype18;
                xfer += iprot->readListBegin(_etype18, _size15);
                this->matrixB[_i14].resize(_size15);
                uint32_t _i19;
                for (_i19 = 0; _i19 < _size15; ++_i19)
                {
                  xfer += iprot->readI32(this->matrixB[_i14][_i19]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.matrixB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->matrixResult.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->matrixResult.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              {
                this->matrixResult[_i24].clear();
                uint32_t _size25;
                ::apache::thrift::protocol::TType _etype28;
                xfer += iprot->readListBegin(_etype28, _size25);
                this->matrixResult[_i24].resize(_size25);
                uint32_t _i29;
                for (_i29 = 0; _i29 < _size25; ++_i29)
                {
                  xfer += iprot->readI32(this->matrixResult[_i24][_i29]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.matrixResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Matrix::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Matrix");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultMatrix", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->resultMatrix);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrixA", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->matrixA.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter30;
    for (_iter30 = this->matrixA.begin(); _iter30 != this->matrixA.end(); ++_iter30)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter30).size()));
        std::vector<int32_t> ::const_iterator _iter31;
        for (_iter31 = (*_iter30).begin(); _iter31 != (*_iter30).end(); ++_iter31)
        {
          xfer += oprot->writeI32((*_iter31));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrixB", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->matrixB.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter32;
    for (_iter32 = this->matrixB.begin(); _iter32 != this->matrixB.end(); ++_iter32)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter32).size()));
        std::vector<int32_t> ::const_iterator _iter33;
        for (_iter33 = (*_iter32).begin(); _iter33 != (*_iter32).end(); ++_iter33)
        {
          xfer += oprot->writeI32((*_iter33));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matrixResult", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->matrixResult.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter34;
    for (_iter34 = this->matrixResult.begin(); _iter34 != this->matrixResult.end(); ++_iter34)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter34).size()));
        std::vector<int32_t> ::const_iterator _iter35;
        for (_iter35 = (*_iter34).begin(); _iter35 != (*_iter34).end(); ++_iter35)
        {
          xfer += oprot->writeI32((*_iter35));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Matrix &a, Matrix &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.resultMatrix, b.resultMatrix);
  swap(a.matrixA, b.matrixA);
  swap(a.matrixB, b.matrixB);
  swap(a.matrixResult, b.matrixResult);
  swap(a.__isset, b.__isset);
}

Matrix::Matrix(const Matrix& other36) {
  id = other36.id;
  resultMatrix = other36.resultMatrix;
  matrixA = other36.matrixA;
  matrixB = other36.matrixB;
  matrixResult = other36.matrixResult;
  __isset = other36.__isset;
}
Matrix& Matrix::operator=(const Matrix& other37) {
  id = other37.id;
  resultMatrix = other37.resultMatrix;
  matrixA = other37.matrixA;
  matrixB = other37.matrixB;
  matrixResult = other37.matrixResult;
  __isset = other37.__isset;
  return *this;
}
void Matrix::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Matrix(";
  out << "id=" << to_string(id);
  out << ", " << "resultMatrix=" << to_string(resultMatrix);
  out << ", " << "matrixA=" << to_string(matrixA);
  out << ", " << "matrixB=" << to_string(matrixB);
  out << ", " << "matrixResult=" << to_string(matrixResult);
  out << ")";
}


